import { Head, Notes, Image } from "mdx-deck";

import { FullScreenCode, Split, SplitRight } from "mdx-deck/layouts";
export { dark as DarkTheme } from "mdx-deck/themes";
import { syntaxHighlighterPrism } from "mdx-deck/themes";
import customTheme from "./theme";

import { CMacro } from "./components/c-macro";
import { BabelConfig } from "./components/babel-config";
import { IDX } from "./components/idx-demo";

export const themes = [syntaxHighlighterPrism, customTheme];

<Head>
  <title>Transform The Future</title>
</Head>

# Transform The Future 🌌 🚀

###### Babel-Plugin-Macros

<Notes>
Jesse Tomchak

@jtomchak

Welcome

</Notes>

---

<h3>What we're gonna cover</h3>

<div style={{ fontSize: 40, textAlign: "left" }}>
  <ul style={{ listStyleType: "none" }}>
    <li>
      🔢 <span style={{ textDecoration: "line-through" }}> Marcos </span>
      Macros
    </li>
    <li>🌊 Usefulness</li>
    <li>🔨 Exapaded Use</li>
    <li>🚀 Future</li>
  </ul>
</div>

<Notes>
- Macros: bit about them, and the problem it sets out to solve
    - Uses in other languages
- Usefulness: their usefulness in day to day development and reducing overhead
- Exapaded Use: from macros to babel plugin macros and what we get out of it
- Future: endless possibilities leveraging macros and more

- Exapanded use in JS

-

</Notes>

---

##### Macros

> Fundamentally, macros are a way of writing code that writes other code,

> like small code generators.

🤔💭

<Notes>

- macros are going to happen at compile time. where a function is going to happen at run time.

- code that writes code. 🤔 This is less readable, understandable, and maintainable then general functions.

- executes "preprocessor statements" at compilation time, and the output of this execution forms part of the code that is compiled.

- tons of languages use macros

- Examples include Scala, Rust, Elixir, Julia, Haskell, C, LISP

</Notes>

---

```
#include <stdio.h>
#define PrintExpr(x) (printf("%s = %d", #x, (x)))

int main(int argc, char **argv)
{
    PrintExpr(2+2);
    return 0;
}

/* Output 😱 2 + 2 = 4 */
```

<Notes>
Here C file with several macros:

the '#' or 'hashtag' is a macro preprocessor that let's you define macros!

1. include -> header file like an 'import'

2 define -> to define a function 'PrintExpr'

3 prefix value with x0's added to non-zero values.

the mathmatical operation as a string !
Without using a macro, there is no way to capture the text string "2+2" so we can print it.

</Notes>

---

# Cool 😎

What's this got to do with JavaScript ?

<Image
  style={{ width: "400px", height: "400px", display: "inline-block" }}
  src="./assets/compiling.png"
/>

<Notes>
- so now we have a quick understanding of a macro, and it's usefulness ...

xkdc cartoon i've always loved

- used to wait for npm install
- now we wait for compile and bundling
- let's make the most of that effort

</Notes>

---

# Babel Compile ♥

<BabelConfig />

<Notes>

- And these things are amazing!!!!
- Transform Plugins
- Modules
- Experimental
- Minification
- Syntax Plugins
- Pluging Ordering [**THIS MATTERS**](https://babeljs.io/docs/en/plugins#plugin-options)
- Presets

Do they run out of order?
**BUT THERE ARE SOME GACHATS**

</Notes>

---

# 🤕 Pain Points 💣

<div style={{ fontSize: 40 }}>
  <ul
    style={{
      listStyleType: "none",
      textAlign: "left",
      display: "inline-block"
    }}
  >
    <li style={{ padding: "10px" }}>😵 Confusion</li>
    <li style={{ padding: "10px" }}>🌎 Globally</li>
    <li style={{ padding: "10px" }}>⚔ Conflict</li>
  </ul>
</div>

<Notes>

- They can lead to _confusion_ because when looking at code in a project, you might not know that there's a plugin transforming that code.
- They have to be _globally configured_ or configured out-of-band (in a .babelrc or webpack config).
- They can _conflict_ in very confusing ways due to the fact that all babel plugins run simultaneously (on a single walk of Babel's AST).

</Notes>

---

# ZERO CONFIG

<a href="https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros">
  <img width="420px" src="./assets/zero-cool.png" />
</a>

<Notes>

- Can we have all those awesome features and mitigate these painpoints?
- Can we get that with zero configurbility?

</Notes>

---

Macros to the rescue 🦹‍♀️🦸‍♀️

<Notes>
  - These are to painpoint that babel-plugin-macros sets out to solve
</Notes>

---

##### [idx](https://github.com/dralletje/idx.macro) In Action

```js
const friends_of_friends =
  props.user == null
    ? props.user
    : props.user.friends == null
    ? props.user.friends
    : props.user.friends[0] == null
    ? props.user.friends[0]
    : props.user.friends[0].friends;
```

---

export default FullScreenCode;

```js
type User = {
  user: ?{
    name: string,
    friends: ?Array<User>
  }
};
props.user &&
  props.user.friends &&
  props.user.friends[0] &&
  props.user.friends[0].friends;
```

---

```js
import idx from "idx.macro";
const friends_of_friends = idx(props, _ => _.user.friends[0].friends);
```

<Notes>T-39 commity stage 0 or stage 1</Notes>

---

#### Babel Language Extentions

```js
//@['optional-chaining']

const friends_of_friends = user?.friends[0]?.friends;
```

---

export default FullScreenCode;

```js
//@['pipe-operator']
let result = exclaim(capitalize(doubleSay("hello")));
result; //=> "Hello, hello!"

//Now with pipes
let result = "hello" |> doubleSay |> capitalize |> exclaim;
result; //=> "Hello, hello!"
```

<Notes>

- something like pragma in Haskell
- declared at the top of any used file, like imports, so you always know

- GHC supports several pragmas, or instructions to the compiler placed in the source code. Pragmas don't normally affect the meaning of the program, but they might affect the efficiency of the generated code.

</Notes>

---

1. Code that continues to be readable
2. Code that is easy for future us to reason about

Language Extenstions allow us to be more surgical with our decisions, and not paint our language with such a broad brush strokes.

---

# Thank you

## 🎆

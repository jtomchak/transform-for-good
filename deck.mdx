import { Head, Notes, Image } from "mdx-deck";

import { FullScreenCode, Split, SplitRight } from "mdx-deck/layouts";
export { dark as DarkTheme } from "mdx-deck/themes";
import { syntaxHighlighterPrism } from "mdx-deck/themes";
import customTheme from "./theme";

import { CMacro } from "./components/c-macro";
import { BabelConfig } from "./components/babel-config";
import { IDX } from "./components/idx-demo";

export const themes = [syntaxHighlighterPrism, customTheme];

<Head>
  <title>Transform The Future</title>
</Head>;

# Transform The Future 🌌 🚀

###### Babel-Plugin-Macros

<Notes>Welcome</Notes>

---

<h3>What we're gonna cover</h3>

<div style={{ fontSize: 40, textAlign: "left" }}>
  <ul style={{ listStyleType: "none" }}>
    <li>
      🔢 <span style={{ textDecoration: "line-through" }}> Marcos </span>
      Macros
    </li>
    <li>🌊 Usefulness</li>
    <li>🔨 Exapaded Use</li>
    <li>🚀 Future</li>
  </ul>
</div>

<Notes>
- Macros: bit about them, and the problem it sets out to solve

- Uses in other languages

- Exapanded use in JS

-

</Notes>

---

##### Macros

> Fundamentally, macros are a way of writing code that writes other code, which is known as metaprogramming.

😪😴

<Notes>

- macros are going to happen at compile time. where a function is going to happen at run time.

- code that writes code. 🤔 This is less readable, understandable, and maintainable then general functions.

- tons of languages use macros

- Haskell, C, Rust, LISP

</Notes>

---

```
#include <stdio.h>
#define PrintExpr(x) (printf("%s = %d", #x, (x)))

int main(int argc, char **argv)
{
    PrintExpr(2+2);
    return 0;
}

/* Output 😱 2 + 2 = 4 */
```

<Notes>
  Here C has 3 macros 1 to include the 
  1. header file like an 'import' 
  2 to define
  a function 'PrintExpr' 
  3 in the function to refer to the value passed into
  that function

Without using a macro, there is no way to capture the text string "2+2" so we can print it.

</Notes>

---

# Cool 😎

What's this got to do with JavaScript ?

<Image
  style={{ width: "400px", height: "400px", display: "inline-block" }}
  src="./assets/compiling.png"
/>

<Notes>

- used to wait for npm install
- now we wait for transpile / bundling
- let's make the most of that effort

</Notes>

---

# Babel compile ♥

```json
{
    "presets": ["react", "es2015", "stage-0"],

    "plugins": [
      "transform-runtime",
      "add-module-exports",
      "transform-decorators-legacy",
      "transform-react-display-name"
    ],

    "env": {
      "development": {
        "plugins": [
          "typecheck",
          ["react-transform", {
              "transforms": [{
                  "transform": "react-transform-catch-errors",
                  "imports": ["react", "redbox-react"]
                }
              ]
          }]
        ]
      }
    }
  }
`;

```

<Notes>

- And these things are amazing!!!!
- Transform Plugins
- Experimental
- Minification
- Syntax Plugins
- Plugim Ordering **THIS MATTERS**
- Plugin Options

**BUT THERE ARE SOME GACHATS**

</Notes>

---

# Downsides

<div style={{ fontSize: 40, textAlign: "left" }}>
  <ul style={{ listStyleType: "none" }}>
    <li style={{ padding: "10px" }}>😵 Confusion</li>
    <li style={{ padding: "10px" }}>🌎 Globally</li>
    <li style={{ padding: "10px" }}>⚔ Conflict</li>
  </ul>
</div>

<Notes>

- They can lead to _confusion_ because when looking at code in a project, you might not know that there's a plugin transforming that code.
- They have to be _globally configured_ or configured out-of-band (in a .babelrc or webpack config).
- They can _conflict_ in very confusing ways due to the fact that all babel plugins run simultaneously (on a single walk of Babel's AST).

</Notes>

---

# ZERO CONFIG

<a href="https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros">
  <img width="420px" src="./assets/zero-cool.png" />
</a>

<Notes>

- Can we have all those awesome features and mitigate these painpoints?
- Can we get that with zero configurbility?

</Notes>

---

Macros to the rescue 🦹‍♀️🦸‍♀️

<Notes>
  - These are to painpoint that babel-plugin-macros sets out to solve
</Notes>

---

##### [idx](https://github.com/dralletje/idx.macro) In Action

```js
const friends_of_friends =
  props.user == null
    ? props.user
    : props.user.friends == null
    ? props.user.friends
    : props.user.friends[0] == null
    ? props.user.friends[0]
    : props.user.friends[0].friends;
```

---

export default FullScreenCode;

```js
type User = {
  user: ?{
    name: string,
    friends: ?Array<User>
  }
};
props.user &&
  props.user.friends &&
  props.user.friends[0] &&
  props.user.friends[0].friends;
```

---

```js
import idx from "idx.macro";
const friends_of_friends = idx(props, _ => _.user.friends[0].friends);
```

---

#### JavaScript Language Extentions

```js
//@['optional-chaining']

const friends_of_friends = user?.friends[0]?.friends;
```

---

export default FullScreenCode;

```js
//@['pipe-operator']
let result = exclaim(capitalize(doubleSay("hello")));
result; //=> "Hello, hello!"

//Now with pipes
let result = "hello" |> doubleSay |> capitalize |> exclaim;
result; //=> "Hello, hello!"
```

<Notes>

- something like pragma in Haskell
- declared at the top of any used file, like imports, so you always know

- GHC supports several pragmas, or instructions to the compiler placed in the source code. Pragmas don't normally affect the meaning of the program, but they might affect the efficiency of the generated code.

</Notes>

---

# Thank you

## 🎆
